Guidelines to be required in the standard

----------------------------------------------------------------

BASIC STRUCTURE

A CCI system consists of the following parts:
- CCI standard header files
- One broker implementation
- One standard parameter implementation
- Potentially additional parameter type implementations
- The user code

----------------------------------------------------------------

CCI STANDARD HEADER FILES

OSCI header files are provided by the include file cci.h
They contain all code needed by user models to write and compile vendor
independent models.
As well the headers are the glue between broker implementation, parameter 
implementation and user model, all being able to be compiled on their own 
and linked together.

All three independent participants (models, parameter implementations, broker
implementations) shall not include each other but only use the cci.h file.

Additional parameter implementation headers shall not be included by the
model or the broker implementation.

Broker implementation headers shall not be included by the model or any
parameter implementation.

----------------------------------------------------------------

BROKER IMPLEMENTATION (TOOL VENDOR)

The library implementing the CCI configuration broker must provide the 
following global functions, declared in file cci_config.h. 
TODO: They shall be available no later than the start of elaboration (e.g. sc_main).
  much earlier!!

  get_cnf_broker_instance(sc_object*)
  get_cnf_broker_instance(const string&)

----------------------------------------------------------------

PARAMETER IMPLEMENTATION

The library implementing the CCI configuration parameters must provide the 
following global functions, declared in the file cci_config.h.

  create_cci_param 
  init_cci_param
  destroy_cci_param


The one standard parameter implementation (library) shall provide the 
following symbols:
- the parameter functions above for (only!) the standard parameter types
- the cci_value implementation for class cci_value in file cci_value.h
Drawback: Such a library might be quite large (e.g. 700 MB in the prototype) due to the 
          symbols of sc_(big)(u)int<width> for all width 
          from 1 to 64 or 1 to e.g. 1024
Workaround within a tool environment:
          Use a Makefile which searches for undefined symbols of the needed 
          parameter factory functions, create and compile a cpp which creates
          exactly those symbols and link afterwards.
          see Makefile.only.needed.symbols in dev_examples/gs_example
          use: make -f Makefile.only.needed.symbols

Potentially additional parameter implementation libraries (or object files) 
shall provide symbols for only one additional parameter type (or a set of
strongly related types).

Thus it is possible to choose one vendor for the standard types and use other 
vendors for additional types.

----------------------------------------------------------------

STANDARD PARAMETER TYPES

Currently proposed data types to be provided by the parameter library:
  int
  unsigned int
  bool
  double
  float
  std::string
  long long
  unsigned char
  signed char
  char
  unsigned short
  std::vector<std::string>
  sc_dt::sc_int_base
  sc_dt::sc_uint_base
  sc_dt::sc_signed
  sc_dt::sc_unsigned
  sc_dt::sc_bit
  sc_dt::sc_logic
  sc_core::sc_time
  sc_dt::sc_int<w> w=1...64
  sc_dt::sc_uint<w> w=1...64
  sc_dt::sc_bigint<w> w=1...1024
  sc_dt::sc_biguint<w> w=1...1024

Any sc_big(u)int with bit width larger than 1024 had to be provided 
by additional parameter implementation (library).

TODO: Check types with C++ standard

----------------------------------------------------------------

JSON STUFF

Uninitialized and invalid:
 Representation for param status uninitialized and invalid: 
 JSON value: null (not the string "null")

sc_time:
 Represenatation for sc_time values:
 as a JSON string: "10 SC_NS"
 The string shall begin with a JSON double number string followed
 by a space and followed by an sc_time_unit string represenation 
 ("SC_FS", "SC_PS", "SC_NS", "SC_US", "SC_MS", "SC_SEC"). 
 The sc_time_unit string shall be not case sensitiv.

----------------------------------------------------------------

REJECT_WRITE CALLBACK 
and
PRE_WRITE CALLBACK

Any reject_write callback is allowed to reject the value (by returning
the according enum item). Thus each observer getting such a callback must
not rely on the given value to appear as the new one - use pre_write instead!

If the value change is rejected (during reject_write), there will be no 
pre_write and no post_write callbacks for this change. If a reject_write
callback rejects the value, all remaining reject_write callbacks shall
still be called.

A pre_write callback must not reject the value write.


----------------------------------------------------------------

CALLBACK ORDER

The callback order must match the registration order. This allows the 
tool to register all desired callbacks prior to all others, because it 
gets the add_param() call at parameter construction.

Note:
This also allows to lock a parameter just on its creation on the highest
hierarchical level, to allow OVM-like precedence (because the highest 
level is able to register for new param callbacks before the lower ones).
(This is true for all callbacks being registered with the same broker,
which is usually the case, private brokers hide private params anyway.)


----------------------------------------------------------------

CALLBACK RETURN STATUS

The parameter implementation shall evaluate the enum returned by callback
functions and perform the according action (e.g. reject a value and throw
a set_param_failed exception).


----------------------------------------------------------------

STRING REPRESENTATION

Parameter string representations are JSON-conform (see http://www.json.org/)
Examples:
 Numbers:
  42
  42.3333
  -42.23e+12
 Strings:
  "Any unicode character but some specials like \" \\ \/"
 bool:
  true
  false
 Objects:
  {"any string":{"any object":42,"another member":43}}


----------------------------------------------------------------

ERROR/WARNING/INFO THROWING

The implementation shall throw sc_reports to report problems (warning/error)
or status (info). The id prefix should be (TODO:) "/OSCI/CCI/" followed by
one of the types defined in cci_error_types.h.


----------------------------------------------------------------

HOW TO GET ACCESS TO BROKERS

Any instance that accesses any CCI configuration feature shall get access to 
its broker and any foreign parameters only by calling  the global 
get_cnf_broker_instance function. (Parameter objects owned by this instance 
shall be created as described elsewhere instantiating the parameter objects.) 
It is recommended to keep the returned pointer due to performance reasons. 
Any CCI parameter but the own ones shall be accessed only through this broker 
and not using separate ways, like e.g. using the child parameter object 
directly. This is to make sure the broker can add the correct originator 
information for debug pupose on parameter accesses.


----------------------------------------------------------------

--
Christian Schr√∂der
christian.schroeder@greensocs.com
