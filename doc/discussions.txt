Discussions about the API and prototype proposal:

----------------------------------------------------------
Libraries, linking, template parameter issue

Because cci parameters are templates, their implementations either need to be provided independently from demand by a large library where the model links to - or they need to be compiled directly with and into the model.

Libraries allow vendor independent coding style, but require large libraries (cp. guidelines.txt).
Header provided implementation require vendor dependent code (due to the include) and require the parameter implementations to be available as source code (with the source code needed to be allowed to be shipped together with the model between different developers).

Current proposal uses the library approach: The cci_param<t> class accesses forward declared factory template functions which are provided by the parameter library. This library needs to provide all needed parameter template types, including all width for the SystemC number types. All other than the set of standard types shall be provided in separate library files to make the standard library file exchangeable.

----------------------------------------------------------
Private broker manager

To be discussed:
The cci_broker_manager_module constructor has _not_ a broker parameter because the owning sc_module shall be already constructed before the private broker mechanism can be used, to ensure the mechanism is allowed to use access the owner module. 
E.g. the private broker should be allowed to get the owning module as a constructor parameter _and use it_ - which it cannot do if the owner is not yet constructed completely. Example: in our implementation the private broker tries to get the next broker upwards the hierarchy which is used to forward _not_ private calls. This fails with a segfault when trying to dynamic cast the owner to get the parent if it is not yet constructed.
Possible option: Don't care for this problem, it has to be solved by the implementation: it cannot rely on the ownner pointer to be valid on construction.

To be discussed as well:
When we provide a function "register_private_broker" which e.g. could be called within the module constructor, this will fail to work for all class member parameters - which is dangerous. Do we want to allow this dangerous behavior? If not: how to support the convenience cci_broker_manager_module which cannot get a (e.g. newed) private broker within the constructor due to previous discussion?

----------------------------------------------------------
Locking Parameter Values (Req.14)

I would prefer to drop the sentence "This does not restrict 
updates to the mapped NVP that are made by other (presumably
unlocked) POs." because it would be cleaner to reject the change
of the NVP as well if the mapped object is locked. That keeps 
the NVP and PH/PO consistent.

----------------------------------------------------------
Mutable/Immutable/Elaboration Time Parameters

The requirements doc lists three different types of read-only params:
- Mutable (Std.) P.
  Mutable ones can be made immutable (locked) temporary 
  by using functions lock(pwd) unlock(pwd) locked().
- Immutable P.
  should be not writable by a tool (but by the owner).
  Can be realized by providing a special set function in the
  PO, possibly requiring the lock pwd.
- Elaboration Time P.
  Elaboration Time P.s should be Mutable until eoe, then lock
First the parameters are not different. 

Our API proposal:
They can be identified (even in static analysis) by an enum 
template parameter. 

----------------------------------------------------------
cci_value implementation/definition

An interesting point is how and where to implement the cci_value thing, 
which allows to set and get values in a generic way.

Options are:
a/ make it an interface (cci_value), which needs to be implemented by
   a vendor (like gs_cci_value, as done for cci_param), or 
b/ to implement it directly in the standard header files (which
   means no vendor specific implementation for the cci_value at all) - or 
c/ define the class and let the vendor implement the functions
   (not another class that implements the interface)


a/   (-) results in vendor dependent code (like needed for cci_params,
         too).
     (+) most flexible for implementation
b/c/ (+) allow the user/application code to use cci_value directly, 
b/   (-) not flexible at all
c/   (-) less flexible, since the standard must define the complete class
         and class members, which cannot be changed by the implementation
         any more

Currently we've chosen c/.

----------------------------------------------------------

There are many more discussions of course...

--
Christian Schr√∂der
christian.schroeder@greensocs.com