Discussions about the API and prototype proposal:

----------------------------------------------------------
Many-to-one Mapping

We propose a weak version of the Many-to-one Mapping:
The Many-to-one Mapping - as it is currently required -
complicates the API and the parameter handling significantly:
- requiring the cci_cnf_api to return multiple objects
  each time being asked for a parameter object (handle) and
- causing complex error handling when value setting cannot be
  applied seamlessly to all mapped objects/handles.
- causing complex callback handling, e.g. syncronizing rejected
  pre_writes, handling callback registering.
Allowing only one Parameter Object or Handle being mapped to
a NVP would keep it simple. Many-to-one mapping can be 
realized with syncronized but dedicated parameters. 
The difference would be that we had different names for the
different POs/PHs. This BTW meets requirement 6 (Superset 
Parameters) as well.

An example for complex error handling - which would need to be 
specified by the standard - is this:
Many PH/POs can be mapped to one NVP.
When any value (PH/PO/NVP) is changed, the change is applied 
immediately to all others.
In detail this means for one NVP with a set of potentially many
PHs and POs:
 - Set one NVP/PH/PO of the set (e.g. by user, tool, model...)
   - if not successfull, throw an set_param_failed error/warning
   - if successfull, set all others 
     (implementation note: e.g. using post_write callbacks)
     foreach:
     - if one fails due to value conversion error (which means that
       the applied value cannot be mapped to a PO's value),
       - make value invalid
       - throw a set_param_failed warning (not an error, because
         an error would not allow to resume with others)
       - go on with others
     - if one fails due to locked or other error,
       - throw a set_param_failed error (leaving the set of
         parameters in an inconsistent state)

This could be swapped out to a synchronization mechanism to
make it clean.

----------------------------------------------------------
Locking Parameter Values (Req.14)

I would prefer to drop the sentence "This does not restrict 
updates to the mapped NVP that are made by other (presumably
unlocked) POs." because (a) this asks for the Many-to-one Mapping
and (b) it would be cleaner to reject the change of the NVP as 
well if the mapped object is locked. That keeps the NVP and PH/PO
consistent.

----------------------------------------------------------
Mutable/Immutable/Elaboration Time Parameters

The requirements doc lists three different types of read-only params:
- Mutable (Std.) P.
  Mutable ones can be made immutable (locked) temporary 
  by using functions lock(pwd) unlock(pwd) locked().
- Immutable P.
  should be not writable by a tool (but by the owner).
  Can be realized by providing a special set function in the
  PO, possibly requiring the lock pwd.
- Elaboration Time P.
  Elaboration Time P.s should be Mutable until eoe, then lock
First the parameters are not different. 

Our API proposal:
They can be identified (even in static analysis) by an enum 
template parameter. We propose to leave it to the param vendor 
to define how to create Immutable or Elaboration Time Parameters.

Different options are:
- provide standard (empty) classes, a parameter implementation can
  derive from, to allow static analysis
- Define alternatives to cci_param<T>, e.g. immutable_cci_param<T>

----------------------------------------------------------
post_read callbacks?

post_read callback discussion: We currently do NOT provide post_read callbacks since they are very hard to define and implement.

----------------------------------------------------------
cci_value implementation/definition

An interesting point is how and where to implement the cci_value thing, which allows to set and get values in a generic way.

Options are:
a/ make it an interface (cci_value), which needs to be implemented by
   a vendor (like gs_cci_value, as done for cci_param), or 
b/ to implement it directly in the standard header files (which
   means no vendor specific implementation for the cci_value at all) - or 
c/ define the class and let the vendor implement the functions
   (not another class that implements the interface)


a/   (-) results in vendor dependent code (like needed for cci_params,
         too).
     (+) most flexible for implementation
b/c/ (+) allow the user/application code to use cci_value directly, 
b/   (-) not flexible at all
c/   (-) less flexible, since the standard must define the complete class
         and class members, which cannot be changed by the implementation
         any more

Currently we've chosen c/.

----------------------------------------------------------
pre_write callbacks returning rejected value change

(also see file guidelines.txt)

Theoretically the pre_write callback can ONLY be used for checking 
and rejecting values. It cannot be used as a pre_write performing 
any action prior to an actual write, because the called function 
cannot know if the write will be rejected by any other called item.

An option is to rename pre_write to e.g. 'reject_write'.

In this case we could add another real pre_write callback if it is 
nescessary to have such.

----------------------------------------------------------
Class names

Currently the cci prefix is doubled: in the namespace and often in 
the class names. E.g.: cci::cci_base_param.
This is preliminary, to be discussed.

----------------------------------------------------------

There are many more discussions of course...