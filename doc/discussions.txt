Discussions about the API and prototype proposal:

----------------------------------------------------------

Private broker manager

To be discussed:
The cci_broker_manager_module constructor has _not_ a broker parameter because the owning sc_module shall be already constructed before the private broker mechanism can be used, to ensure the mechanism is allowed to use access the owner module. 
E.g. the private broker should be allowed to get the owning module as a constructor parameter _and use it_ - which it cannot do if the owner is not yet constructed completely. Example: in our implementation the private broker tries to get the next broker upwards the hierarchy which is used to forward _not_ private calls. This fails with a segfault when trying to dynamic cast the owner to get the parent if it is not yet constructed.
Possible option: Don't care for this problem, it has to be solved by the implementation: it cannot rely on the owniner pointer to be valid on construction.

To be discussed as well:
When we provide a function "register_private_broker" which e.g. could be called within the module constructor, this will fail to work for all class member parameters - which is dangerous. Do we want to allow this dangerous behavior? If not: how to support the convenience cci_broker_manager_module which cannot get a (e.g. newed) private broker within the constructor due to previous discussion?

----------------------------------------------------------
Locking Parameter Values (Req.14)

I would prefer to drop the sentence "This does not restrict 
updates to the mapped NVP that are made by other (presumably
unlocked) POs." because it would be cleaner to reject the change
of the NVP as well if the mapped object is locked. That keeps 
the NVP and PH/PO consistent.

----------------------------------------------------------
Mutable/Immutable/Elaboration Time Parameters

The requirements doc lists three different types of read-only params:
- Mutable (Std.) P.
  Mutable ones can be made immutable (locked) temporary 
  by using functions lock(pwd) unlock(pwd) locked().
- Immutable P.
  should be not writable by a tool (but by the owner).
  Can be realized by providing a special set function in the
  PO, possibly requiring the lock pwd.
- Elaboration Time P.
  Elaboration Time P.s should be Mutable until eoe, then lock
First the parameters are not different. 

Our API proposal:
They can be identified (even in static analysis) by an enum 
template parameter. 

----------------------------------------------------------
post_read callbacks?

post_read callback discussion: We currently do NOT provide post_read callbacks since they are very hard to define and implement.

----------------------------------------------------------
cci_value implementation/definition

An interesting point is how and where to implement the cci_value thing, which allows to set and get values in a generic way.

Options are:
a/ make it an interface (cci_value), which needs to be implemented by
   a vendor (like gs_cci_value, as done for cci_param), or 
b/ to implement it directly in the standard header files (which
   means no vendor specific implementation for the cci_value at all) - or 
c/ define the class and let the vendor implement the functions
   (not another class that implements the interface)


a/   (-) results in vendor dependent code (like needed for cci_params,
         too).
     (+) most flexible for implementation
b/c/ (+) allow the user/application code to use cci_value directly, 
b/   (-) not flexible at all
c/   (-) less flexible, since the standard must define the complete class
         and class members, which cannot be changed by the implementation
         any more

Currently we've chosen c/.

----------------------------------------------------------
pre_write callbacks returning rejected value change

(also see file guidelines.txt)

Theoretically the pre_write callback can ONLY be used for checking 
and rejecting values. It cannot be used as a pre_write performing 
any action prior to an actual write, because the called function 
cannot know if the write will be rejected by any other called item.

An option is to rename pre_write to e.g. 'reject_write'.

In this case we could add another real pre_write callback if it is 
necessary to have such.

----------------------------------------------------------
Class names

Currently the cci prefix is doubled: in the namespace and often in 
the class names. E.g.: cci::cci_base_param.
We discussed and this is OSCI pratice thus ok this way.

----------------------------------------------------------
Emulating OVM hierarchical precedence

Discussion how to emulate the OVM hierarchical setting
mechanism with the parameter object proposal


For Parameters being used during construction:

All alternatives need the subsystem to be created after some initial 
value being set or the lock or cb can be applied/called before the 
param construction within the child module.

Alternatives 
 discussion on 5/26: #2. or #3. is favorite, 
 decision on 6/2: choose #2 because keeps things simple and clean
 with very easy rules

1. Coding:
    - Set init value (optionally)
    - register new param cb
    - instantiate the child module
    - on new param cb, (if it is the desired param)
       - set the value (to overwrite other's init values)
       - and lock the param
    - unlock at end of constructor again
   Preconditions:
    - none (possible with current proposal, because new param callbacks
            are called in the order of their registration order)
   Drawbacks:
    - set_init_value call cannot be used, since the value
      needs to be set within the callback function

2. Coding:
    - Set initial value
    - lock the initial value
    - instantiate the child module
   Preconditions:
    - needs the option to lock init values within the broker
   Drawback:
    - complicates broker API:
      inconsequent because the 'lock' feature is duplicated in the broker
      *and* the object
      (we discussed: not too bad)
   Summary:
    The broker has an additional API function allowing to lock an 
    initial value.

3. Coding:
    - set_init_value_not_overriding_existing_initial_value("C.p", 0);
    - instantiate the child module
   Preconditions:
    - additional broker function that locks the init value from being 
      overwritten by later set_init_value calls
   Drawback:
    - complicates broker API:
      two different set_init_value functions
      (one like current one, allowing overwrites
      + one additional function locking the init value)
   Summary:
    Similar to #2.
    The broker has an additional API function implcitily locking the 
    initial value.

4. Coding rule:
    - When a module sets a parameter
      (e.g. C.p by calling set_init_value("C.p", 0)), it must first 
      check if there is already an initial value being set (e.g. by 
      calling getValue(paramname) )
   Preconditions:
    - none (possible with current proposal)
   Drawback:
    - highly unreliable because any module can easily ignore this rule
   Summary:
    Not an option at all, very bad


For Parameters being used later than construction:
  Coding rule:
    - Just set the parameter value after the construction call.
    - The hierarchically most top level will overwrite all previous settings.

----------------------------------------------------------

There are many more discussions of course...