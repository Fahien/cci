Notes
-----
The following definitions are in line with the requirements doc
but making the words more concrete:

Parameter Handle (PH): Parameter access object allowing typeless
(JSON) string access. This is the cci_base_param.

Parameter Object (PO): Parameter access object being typed. This
is derived from the PH, thus it is the same object.

Name-Value-Pair (NVP): Conceptional pair of the unique 
hierarchical parameter name and the (JSON) string value. It is
up to the implementation where this is stored (e.g. in a database
or in PHs). The value is consistent with the PH/PO's one at any
time.

----------------------------------------------------------------

CALLBACKS

Callback registration methods return shared pointers 
to callback adapters. Advantage: the callback will automatically 
destroyed when no smart pointer to the callback adapter exists 
any longer. The only rule is: 
Rule: Store the returned shared pointer and keep it until you want
      the callback to be deleted.

BTW: The shared pointer handling does not cause any memory leak.

* Why not using SCV callback mechanism of scv_smart_ptr? *

The scv_extension_if provides in the form of 
scv_extension_callbacks_if a similar callback mechanism we have 
in mind. The biggest problem is the lack of callback types 
pre/post-read and pre-write, only post-write (value change) is 
provided. 
Unfortunately extending the SCV mechanism is not possible because 
there is the method get_instance() which returns a non-constant 
pointer to the underlying object, which then can be changed and 
the trigger_value_change_cb() function needs to be called 
manually (SCV Spec. v.1.0e, p.22). When introducing further 
callback types to SCV we would need to change the SCV standard 
according the user rules to this get_instance() call, which is 
no option.
Another disadvantage is that callback method parameter needs to 
be an object of type scv_extensions_if - which would require a 
big amount of methods to be implemented by the parameters.

Therefore I suggest we adopt the proposed approach which is aligned 
to the SCV approach: We use register/remove method calls which look 
similar but take a different function pointer which gets a 
cci_base_param object and a callback_type. It will therefore look 
and feel similar, but will have the added benefits we need in CCI 
(more callback types and different objects given to the called 
functions).
I prefer the shared_ptr approach (the register/add method 
returns such a pointer instead of an SCV-like callback ID) to 
reduce the danger of memory leaks which may occur when just 
newing callback objects.

----------------------------------------------------------------

PORTABILITY

One aspect ensuring portability is the used data type sc_dt::uint64. 
Since this standard is a SystemC standard, this should be the data 
type used. 
"int64 is a native C++ integer type having a word length of exactly 
64 bits.", "uint64 is a native C++ unsigned integer type having a 
word length of exactly 64 bits." 
(IEEE Standard SystemC Language Reference Manual, March 2006).

----------------------------------------------------------------

THROWING ERRORS

The proposal uses sc_report to report errors/warnings/infos like 
bad values, bad types etc. The used message type prefix is 
"/OSCI/CCI/". These sc_reports can be handled by the application
very elegant and SystemC-like, and can be switched off or even 
catched locally.
Using sc_report for throwing exceptions is advisable because 
catching other exceptions being thrown in e.g. sc_threads is
hard to do for the user.

----------------------------------------------------------------

PRIVATE BROKERS

The user can derive from cci_broker_manager_module to create an 
sc_module which can hold a private broker.
This private broker either can be given during construction to 
the constructor or later using a function call. If none is given,
the broker manager will automatically search for the responsible
one in the hierarchy upwards.

----------------------------------------------------------------

christian.schroeder@greensocs.com
